<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Smakime Neonin 3D</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { margin:0; overflow:hidden; background:#000; }

#mobileControls {
  position:fixed;
  bottom:20px;
  left:50%;
  transform:translateX(-50%);
  display:flex;
  gap:10px;
  z-index:10;
}

button {
  font-size:22px;
  padding:14px 20px;
  opacity:0.75;
}
</style>
</head>
<body>

<div id="mobileControls">
  <button id="left">◀</button>
  <button id="jump">⤴</button>
  <button id="right">▶</button>
</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
/* ========== SCENE ========== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(
  75, window.innerWidth / window.innerHeight, 0.1, 1000
);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ========== LIGHT ========== */
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const sun = new THREE.DirectionalLight(0xffffff,1);
sun.position.set(5,10,5);
scene.add(sun);

/* ========== PLAYER (2D IMAGE) ========== */
const loader = new THREE.TextureLoader();

// ✅ LOCAL IMAGE FILE
const playerTex = loader.load("mango2.png");

const PLAYER_W = 1;
const PLAYER_H = 2;

const player = new THREE.Mesh(
  new THREE.PlaneGeometry(PLAYER_W, PLAYER_H),
  new THREE.MeshBasicMaterial({
    map: playerTex,
    transparent:true
  })
);
player.position.set(0,2,0);
scene.add(player);

/* ========== PLATFORMS ========== */
const platforms = [];
function addPlatform(x,y,w){
  const p = new THREE.Mesh(
    new THREE.BoxGeometry(w,1,5),
    new THREE.MeshStandardMaterial({color:0x444444})
  );
  p.position.set(x,y,0);
  scene.add(p);
  platforms.push(p);
}

addPlatform(0,0,10);
addPlatform(7,2,6);
addPlatform(15,4,6);
addPlatform(24,6,6);

/* ========== PHYSICS ========== */
let velY = 0;
let onGround = false;
let facing = 1;

const gravity = 0.015;
const speed = 0.08;
const jumpPower = 0.35;

/* ========== INPUT ========== */
const keys = {};
addEventListener("keydown",e=>keys[e.key]=true);
addEventListener("keyup",e=>keys[e.key]=false);

const mobile = {left:false,right:false,jump:false};
["left","right","jump"].forEach(id=>{
  const b=document.getElementById(id);
  b.addEventListener("touchstart",e=>{
    e.preventDefault();
    mobile[id]=true;
  });
  b.addEventListener("touchend",()=>mobile[id]=false);
});

/* ========== CAMERA CONTROLS ========== */
let camAngle=0, camTilt=0.3, camDistance=8;
let drag=false, tx=0, ty=0, lastPinch=null;

addEventListener("touchstart",e=>{
  if(e.touches.length===1){
    drag=true;
    tx=e.touches[0].clientX;
    ty=e.touches[0].clientY;
  }
});

addEventListener("touchmove",e=>{
  if(e.touches.length===1 && drag){
    camAngle -= (e.touches[0].clientX-tx)*0.005;
    camTilt  -= (e.touches[0].clientY-ty)*0.005;
    camTilt = Math.max(0.1,Math.min(1.2,camTilt));
    tx=e.touches[0].clientX;
    ty=e.touches[0].clientY;
  }

  if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    const d=Math.hypot(dx,dy);
    if(lastPinch!==null){
      camDistance -= (d-lastPinch)*0.01;
      camDistance = Math.max(4,Math.min(14,camDistance));
    }
    lastPinch=d;
  }
});

addEventListener("touchend",()=>{
  drag=false;
  lastPinch=null;
});

/* ========== CAMERA COLLISION ========== */
const raycaster=new THREE.Raycaster();

/* ========== GAME LOOP ========== */
function animate(){
  requestAnimationFrame(animate);

  const prevX = player.position.x;
  const prevY = player.position.y;

  /* Horizontal */
  let moveX=0;
  if(keys["a"]||keys["ArrowLeft"]||mobile.left){moveX-=speed; facing=-1;}
  if(keys["d"]||keys["ArrowRight"]||mobile.right){moveX+=speed; facing=1;}
  player.position.x += moveX;

  /* Jump */
  if((keys[" "]||keys["w"]||keys["ArrowUp"]||mobile.jump)&&onGround){
    velY=jumpPower;
    onGround=false;
  }

  /* Gravity */
  velY -= gravity;
  player.position.y += velY;

  /* COLLISION (STABLE) */
  onGround=false;

  platforms.forEach(p=>{
    const pBox=new THREE.Box3().setFromObject(p);
    const box=new THREE.Box3(
      new THREE.Vector3(player.position.x-PLAYER_W/2, player.position.y, -0.5),
      new THREE.Vector3(player.position.x+PLAYER_W/2, player.position.y+PLAYER_H, 0.5)
    );

    if(!box.intersectsBox(pBox)) return;

    // Vertical first
    if(prevY >= pBox.max.y && velY<=0){
      player.position.y = pBox.max.y;
      velY=0;
      onGround=true;
      return;
    }

    // Side block
    if(prevX < pBox.min.x){
      player.position.x = pBox.min.x - PLAYER_W/2;
    } else if(prevX > pBox.max.x){
      player.position.x = pBox.max.x + PLAYER_W/2;
    }
  });

  /* Sprite flip */
  player.lookAt(camera.position);
  player.scale.x=facing;

  /* Camera follow + collision */
  const camTarget=new THREE.Vector3(
    player.position.x+Math.sin(camAngle)*camDistance,
    player.position.y+3+camTilt*3,
    Math.cos(camAngle)*camDistance
  );

  raycaster.set(
    player.position,
    camTarget.clone().sub(player.position).normalize()
  );
  const hit=raycaster.intersectObjects(platforms);
  if(hit.length && hit[0].distance<camDistance){
    camTarget.copy(hit[0].point);
  }

  camera.position.lerp(camTarget,0.12);
  camera.lookAt(player.position.x,player.position.y+1,player.position.z);

  renderer.render(scene,camera);
}

animate();

/* ========== RESIZE ========== */
addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>

</body>
</html>
